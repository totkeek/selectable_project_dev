設問が1以上表示される画面がn(0 < n)ページあり。1ページ目からnページ目にかけて1ページづつ遷移する。戻る場合も同様。
nページ内の設問に回答したのち、つぎの画面へ遷移すると結果画面が表示される

要件として、設問の回答状況によって、設問が表示非表示、別の設問が表示される制約がある。また、設問の回答状況によって設問内の選択肢の種類、順序、グルーピングが変化する

階層としては、画面→設問→選択肢グループ→選択肢ですね。
                    ↓→グルーピング

イメージとしては、
設問に回答
↓
設問の回答と過去に回答した他の回答状況を合わせて、次の設問を決定
↓
設問
↓
設問の回答と過去に回答した他の回答状況を合わせて、設問に表示する選択肢グループを決定
↓
設問の回答と過去に回答した他の回答状況を合わせて、設問に表示する選択肢をどのようにグルーピングとフィルタリングするかを決定
↓
選択肢をグルーピングとフィルタリングを行いながらソートする
↓
設問と選択肢を表示

選択肢の表示順についてのイメージはこんなかんじ

選択肢グループ内には、選択肢があり表示順がきまっている。
1つの設問に選択肢グループが2つ以上ある場合、グループ単位で表示順がある。(回答状況によって、設問XではグループAとグループBを1,2の順で並べますみたいな)なので、グループ単位を管理するテーブルや設問そのものには表示順はない
なので、グループ単位の表示順→グループ内の選択肢の表示順です。このソートが終わったあとに、ソート順をくずさないようにグルーピングを行う。

グルーピングについては、そもそも選択肢が親子構造なのを利用します。例えば水栓は、メーカ→図番→品番 水栓管理番号→図番→品番 の親子構造があります。メーカ、水栓管理番号、図番、品番のうち、基本的に選択肢として表示するのは品番のみですが、他の要素も選択肢として登録します。

---

## 実装予定機能のDB設計案

### 1. 回答状況による選択肢グループ決定

**目的**: 設問の回答内容に応じて、表示する選択肢グループを動的に切り替える

| テーブル名 | 説明 | 主要カラム |
|-----------|------|-----------|
| `question_group_rules` | 設問に対する選択肢グループ表示ルール | `id`, `project_id`, `question_id`, `priority` |
| `question_group_conditions` | グループ表示の条件 | `id`, `rule_id`, `condition_question`, `condition_operator`, `logical_operator`, `condition_group` |
| `question_group_condition_values` | 条件の値 | `id`, `condition_id`, `value` |
| `question_group_actions` | 条件を満たした場合のアクション | `id`, `rule_id`, `target_group_id`, `sort_order` |

**動作イメージ**:
- Q1で「キッチン」を選択 → Q2には「キッチン用グループA」「キッチン用グループB」を表示
- Q1で「浴室」を選択 → Q2には「浴室用グループC」を表示

### 2. 回答状況による選択肢グルーピング方法の決定

**目的**: 同じ選択肢でも、回答状況によって表示のグルーピング方法を変える

| テーブル名 | 説明 | 主要カラム |
|-----------|------|-----------|
| `choice_grouping_rules` | 選択肢のグルーピング表示ルール | `id`, `project_id`, `question_id`, `priority` |
| `choice_grouping_conditions` | グルーピング条件 | `id`, `rule_id`, `condition_question`, `condition_operator`, `logical_operator`, `condition_group` |
| `choice_grouping_condition_values` | 条件の値 | `id`, `condition_id`, `value` |
| `choice_grouping_config` | グルーピング設定 | `id`, `rule_id`, `group_by_attribute_id`, `display_level`, `show_parent_label` |

**動作イメージ**:
- 予算「高」選択時 → 水栓を「メーカー別」にグルーピング表示
  ```
  [TOTO]
    - 品番A
    - 品番B
  [LIXIL]
    - 品番C
  ```
- 予算「低」選択時 → 水栓を「図番別」にグルーピング表示
  ```
  [図番X]
    - 品番A
    - 品番D
  [図番Y]
    - 品番E
  ```

### 3. 既存テーブルの実装状況

| 機能 | 実装状況 | 使用テーブル |
|------|---------|-------------|
| ✅ 回答状況による設問の表示/非表示 | **実装済み** | `dynamic_question_rules`, `dynamic_question_conditions`, `dynamic_question_condition_values` |
| ⏳ 回答状況による選択肢グループ決定 | **未実装** | (上記テーブル案を参照) |
| ⏳ 回答状況によるグルーピング方法決定 | **未実装** | (上記テーブル案を参照) |

---

## DB設計の修正事項（TODO）

### 外部キー制約の追加

- [ ] **`dynamic_question_conditions.condition_question`** に外部キー制約を追加
  - 参照先: `question(id)`
  - 現状、条件対象の設問IDが外部キー未設定のため整合性が保証されていない

```sql
ALTER TABLE `dynamic_question_conditions`
ADD CONSTRAINT `FK_dynamic_question_conditions_question`
FOREIGN KEY (`condition_question`) REFERENCES `question` (`id`);
```

### その他の改善候補

- [ ] `dynamic_question_rules.name` のデータ型を `VARCHAR(50)` に変更（現在`INT`になっている）
- [ ] `view_structure_potision` のスペルを `view_structure_position` に修正
- [ ] `choice_family.child_choiceid` を `child_choice_id` に修正（命名規則統一）
- [ ] `session.session_key` を `CHAR(255)` → `VARCHAR(255)` に変更（容量最適化）

---

## 補足: ルールエンジンの共通構造

上記3つの機能（設問表示・グループ決定・グルーピング方法）は全て同じパターンで設計可能:

```
ルールテーブル (何に対するルールか)
  ├─ 条件テーブル (どんな条件か)
  │   └─ 条件値テーブル (具体的な値)
  └─ アクションテーブル (条件を満たしたら何をするか)
```

このパターンを統一することで、実装やメンテナンスが容易になる。

---

## 設計オプション: ルール統括マスタテーブルの導入

### 概要

全ルールタイプ（設問表示、グループ決定、グルーピング方法）を統括管理するマスタテーブルの導入を検討する価値がある。

### 統括ルール構造

```
rule_master (統括ルールマスタ)
  ├─ dynamic_question_rules (設問表示ルール)
  ├─ question_group_rules (グループ決定ルール) 
  └─ choice_grouping_rules (グルーピング方法ルール)
```

### テーブル設計

#### rule_master (統括ルールマスタ)

| カラム名 | 型 | NULL | デフォルト | 説明 |
|---------|-----|------|-----------|------|
| `id` | `INT UNSIGNED` | NO | AUTO_INCREMENT | 主キー |
| `project_id` | `INT UNSIGNED` | NO | - | プロジェクトID |
| `rule_type` | `ENUM('QUESTION_DISPLAY', 'GROUP_SELECT', 'GROUPING_METHOD')` | NO | - | ルール種別 |
| `name` | `VARCHAR(100)` | NO | - | ルール名（管理用） |
| `description` | `TEXT` | YES | NULL | ルール説明 |
| `is_active` | `TINYINT(1)` | NO | `1` | 有効/無効フラグ |
| `priority` | `INT UNSIGNED` | NO | `0` | グローバル優先順位 |
| `created_at` | `TIMESTAMP` | NO | `CURRENT_TIMESTAMP` | 作成日時 |
| `updated_at` | `TIMESTAMP` | NO | `CURRENT_TIMESTAMP ON UPDATE` | 更新日時 |

**インデックス**:
- PRIMARY KEY (`id`)
- INDEX (`project_id`)
- INDEX (`project_id`, `rule_type`, `priority`)

**外部キー**:
- `project_id` → `project(id)`

#### 既存ルールテーブルへの追加カラム

各ルールテーブル（`dynamic_question_rules`, `question_group_rules`, `choice_grouping_rules`）に以下を追加:

| カラム名 | 型 | NULL | デフォルト | 説明 |
|---------|-----|------|-----------|------|
| `rule_master_id` | `INT UNSIGNED` | NO | - | 統括ルールマスタID |

**外部キー**:
- `rule_master_id` → `rule_master(id)` `ON DELETE CASCADE`

### SQL作成例

```sql
-- 統括ルールマスタテーブル
CREATE TABLE `rule_master` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `project_id` int unsigned NOT NULL,
  `rule_type` enum('QUESTION_DISPLAY', 'GROUP_SELECT', 'GROUPING_METHOD') COLLATE utf8mb4_unicode_ci NOT NULL,
  `name` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL,
  `description` text COLLATE utf8mb4_unicode_ci,
  `is_active` tinyint(1) NOT NULL DEFAULT '1',
  `priority` int unsigned NOT NULL DEFAULT '0',
  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `project_id` (`project_id`),
  KEY `project_rule_priority` (`project_id`, `rule_type`, `priority`),
  CONSTRAINT `FK_rule_master_project` FOREIGN KEY (`project_id`) REFERENCES `project` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='ルール統括マスタ';

-- 既存テーブルへのカラム追加例 (dynamic_question_rules)
ALTER TABLE `dynamic_question_rules`
ADD COLUMN `rule_master_id` int unsigned NOT NULL AFTER `id`,
ADD CONSTRAINT `FK_dynamic_question_rules_master` 
  FOREIGN KEY (`rule_master_id`) REFERENCES `rule_master` (`id`) ON DELETE CASCADE;
```

### メリット

| メリット | 説明 |
|---------|------|
| 🎯 **一元管理** | 全ルールを`rule_master`で一覧・検索可能。管理画面での操作性向上 |
| 📊 **優先順位の統合管理** | 異なるルールタイプ間での実行順序を制御可能 |
| 🔧 **ON/OFF切り替え** | `is_active`で全ルールタイプを統一的に制御。A/Bテストやデバッグが容易 |
| 📝 **監査・ログ** | `created_at`, `updated_at`で変更履歴を追跡しやすい |
| 🚀 **拡張性** | 新しいルールタイプ（例: 価格計算、フィルタリング）を追加しやすい |
| 🔍 **デバッグ性** | 「このルールだけ無効化」が簡単。問題の切り分けが容易 |

### デメリット

| デメリット | 対策 |
|----------|------|
| ⚡ **JOINが増える** | インデックスを適切に設定。ルール評価は画面遷移時のみなので影響は限定的 |
| 📐 **初期設計の複雑化** | 長期的には保守性が向上するため投資価値あり |

### 実装判断基準

| 条件 | 推奨度 | 理由 |
|------|-------|------|
| ルールタイプが3種類以上 | ⭐⭐⭐ **強く推奨** | 管理の煩雑さが顕著に |
| 管理画面での操作性を重視 | ⭐⭐⭐ **強く推奨** | UI/UXが大幅に改善 |
| 将来的な機能拡張を想定 | ⭐⭐ **推奨** | 拡張が容易になる |
| 最小構成で済ませたい | ⭐ **不要** | オーバーエンジニアリングのリスク |

### 使用例: ルールの一覧取得

```sql
-- プロジェクト1の全ルールを優先順位順で取得
SELECT 
  rm.id,
  rm.rule_type,
  rm.name,
  rm.is_active,
  rm.priority,
  CASE rm.rule_type
    WHEN 'QUESTION_DISPLAY' THEN dqr.id
    WHEN 'GROUP_SELECT' THEN qgr.id
    WHEN 'GROUPING_METHOD' THEN cgr.id
  END as detail_rule_id
FROM rule_master rm
LEFT JOIN dynamic_question_rules dqr ON rm.id = dqr.rule_master_id
LEFT JOIN question_group_rules qgr ON rm.id = qgr.rule_master_id
LEFT JOIN choice_grouping_rules cgr ON rm.id = cgr.rule_master_id
WHERE rm.project_id = 1
  AND rm.is_active = 1
ORDER BY rm.priority ASC;
```

### 設計の選択肢（最終判断保留）

#### 案A: 統括ルールマスタあり

**採用すべきケース:**
- 管理画面で全ルールを横断的に管理したい
- ルールタイプが今後5種類以上に増える可能性が高い
- グローバルな優先順位制御が必要
- ON/OFF切り替えによるA/Bテストを頻繁に行う

**メリット:**
- 全ルールの一元管理・一覧表示が容易
- デバッグ性が高い（個別ルールの無効化が簡単）
- 監査ログが統一的に取れる

**デメリット:**
- 初期実装が複雑
- 毎回JOINが必要（ただし影響は限定的）

#### 案B: 各ルールテーブル独立型（統括マスタなし）

**採用すべきケース:**
- シンプルな構成を優先したい
- 各ルールの処理フローが明確に独立している
- 現時点でルールタイプは3種類で確定している
- YAGNI原則（必要になってから追加）を重視

**メリット:**
- テーブル構造がシンプルで理解しやすい
- JOINが不要でパフォーマンスが良い
- 各機能が独立しており、実装・メンテナンスが容易

**デメリット:**
- 全ルールの一覧取得にはアプリケーション層での統合処理が必要
- ルールタイプが増えると管理が煩雑になる可能性

**必須対応（案Bの場合）:**
各ルールテーブルに以下のカラムを必ず追加:
```sql
`is_active` TINYINT(1) NOT NULL DEFAULT 1,
`priority` INT UNSIGNED NOT NULL DEFAULT 0,
`created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
`updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
```

---

## 判断基準の整理

| 観点 | 案A（統括マスタあり） | 案B（独立型） |
|------|---------------------|--------------|
| **実装の複雑さ** | ⚠️ 複雑 | ✅ シンプル |
| **管理画面の作りやすさ** | ✅ 一元管理UI | ⚠️ 個別UI必要 |
| **パフォーマンス** | ⚠️ JOIN必要 | ✅ 高速 |
| **将来の拡張性** | ✅ 高い | ⚠️ 中程度 |
| **デバッグのしやすさ** | ✅ 容易 | ⚠️ やや手間 |
| **YAGNI原則** | ⚠️ 過剰設計リスク | ✅ 必要最小限 |

### 推奨の判断ポイント

**現時点での処理フロー:**
```
設問に回答 → 次の設問決定 → グループ決定 → グルーピング方法決定
```
↑これらは**順次実行される独立した処理**

**結論:**
- 処理が独立している → **案B（独立型）を推奨**
- ただし将来的に統合管理が必要になったら案Aに移行可能

**最終判断は保留** - 実装開始前に決定すること

